%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{System architecture and Methods}\label{ch:architecture}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%3nd-review
In this chapter, we will present our tool which aims to fill the gaps addressed in the chapter ~\ref{ch:introduction}. It is called SIMITAR (SnIffing, ModellIng and TrAffic geneRation) and aims to generate a platform-agnostic traffic: it can be extended to almost any traffic engine, including traffic generators tools and APIs. SIMITAR creates a  model in XML, configured using actual traces (from \textit{pcaps} or real-time sniffing), we call Compact Trace Descritor (CTD). 


We abstract its whole operation cycle in the figure ~\ref{fig:cycle-of-operation}. Our tool, from live captures or \textit{pcap} file collects raw data from Ethernet traffic. It then breaks these data into different flows and uses this data to generate a set of parameters for our traffic model, using a set of algorithms. Finally, SIMITAR provides these parameters to a traffic generator engine and controls its packets injection.

% cycle of operation
%2nd-review
\begin{figure*}[ht!]
        \centering
        \includegraphics[height=3.0in]{figures/ch3/digram-project-cycle}
        \caption{This figure represents an operation cycle of SIMITAR, emphasizing each main step: sniffing, flow classification, data storing, data processing and fitting, model parameterization,  and synthetic traffic generation.}
    \label{fig:cycle-of-operation}
\end{figure*}


\section{SIMITAR Architecture}


To meet the requirements presented in the section ~\ref{ch:introduction}, we will present a solution, and define how each part works, as in a low-level requirement list\cite{sommerville}. SIMITAR architecture is presented in the figure~\ref{fig:architecture}, and it is composed of for components: a \textit{Sniffer}, a \textit{SQLite database}, a \textit{TraceAnalyzer}, a \textit{FlowGenerator};  and a \textit{Network Traffic Generator}, as subsystem. We describe each part below.

% component diagram and module design
\begin{figure*}[ht!]
        \centering
        \includegraphics[height=2.7in]{figures/ch3/architecture-diagram}
        \caption{Architecture of SIMITAR}
    \label{fig:architecture}
\end{figure*}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Sniffer}

%2nd-review
This component collects network traffic data and classifies it into flows, storing stores in an SQLite database. It defines each flow by the same criteria used by SDN switches\cite{sdn-survey}, through header fields matches (Link Protocol, Network Protocol, Network Source Address, Network Destination Address, Transport Protocol, Transport Source Port, Transport Destination Port). It can work over a \textit{pcap} file or over an Ethernet interface. 

\begin{figure*}[ht!]
        \centering
        \includegraphics[height=2.5in]{figures/ch3/sniffer-classifier}
        \caption{SIMITAR's sniffer hash-based flow classification}
    \label{fig:sniffer}
\end{figure*}


The first version of this component was implemented in Shell Script (Bash).  Tsahrk\footnote{\href{https://www.wireshark.org/docs/man-pages/tshark.html}{https://www.wireshark.org/docs/man-pages/tshark.html}} was used to extract header fields, and Awk to match the flows, and Sed/Awk to create the Sqlite queries. This version was too slow to operate in real time on Ethernet interfaces. On the other hand, was fast to implement, and enable the implementation of the other components, before this last version was released. The second and cuerrent version is implemented using Python. This version used Pyshark \footnote{\href{https://pypi.python.org/pypi/pyshark}{https://pypi.python.org/pypi/pyshark}} as sniffer library.  


It has a data structure we developed called \textit{OrderedSet}. A set is a list of elements with no repetition but do not keep track of the insertion order. Our OrderedSet does. Also, it make use of a  64 bits hash function of the family FNV\footnote{The collision probability of a good 64 bits hash function in a table with 10000 items is about of $2.71e-12$.}. The listed header fields are inputs for a hash function, its value is set on the ordered set, and its order(index on the \textit{OrderedSet}) is returned. The index value is set as a packet flowID.  

%c++ http://ideone.com/F0V42m
%2nd-review
As future improvements for this component, we propose a more efficient implementation in C++ and data visualization for the collected data. We discuss this in deeper details in the chapter~\ref{ch:conclusion}.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{SQLite database}

\begin{figure*}[ht!]
        \centering
        \includegraphics[height=3.0in]{figures/ch3/database-relational-model}
        \caption{SIMITAR's SQLite database relational model}
    \label{fig:simitar-database}
\end{figure*}


The database stores the collected raw data  from the traces for further analysis. The \textit{Sniffer} and the \textit{TraceAnalyzer} components uses the database.  We choose an SQLite database, because according to its specifications\footnote{\href{https://www.sqlite.org/whentouse.html}{https://www.sqlite.org/whentouse.html}}, it fits well our porposes. It is simple and well-suitable for an amount of data smaller than terabytes. In the figure ~\ref{fig:simitar-database} we present the relational model of our database, which stores a set of features extracted from packets, along with the flowID calculated by the sniffer component. 


\subsection{Trace Analyzer}


This module is the core of our project. It creates a trace model via the analysis of the collected data. We define here a Compact Trace Descriptor (CTD) as a human and machine readable file, which describes an original traffic trace trough a set of flows, each of them described by a set of parameters, like header information and analytical models. 


Therefore, the Trace Analyze learns the features from raw data of traces (stored in the SQLite database) and write them in an XML file.  In the figure~\ref{fig:CTD-diagram} we show a directory diagram of a CDT file. It has many of many flow fields, and each one contains each parameter estimated. 

%\begin{figure*}[!ht]
%    \centering
%    \begin{subfigure}[t]{0.45\textwidth}
%        \centering
%        \includegraphics[height=2.5in]{figures/03_compact_trace_descriptor_tree_structure}
%        \caption{caption}
%    \end{subfigure}%
%    ~ 
%    \begin{subfigure}[t]{0.45\textwidth}
%        \centering
%        \includegraphics[height=2.5in]{figures/03_compact_trace_descriptor_tree_structure_2}
%        \caption{caption}
%    \end{subfigure}
%    \caption{caption}
%    \label{fig:CTD-diagram}
%\end{figure*}
%height=2.5in
%


\begin{figure}
\centering
\subfloat[first]{
  \includegraphics[height=4.in]{figures/ch3/cdt1}
}
\subfloat[second]{
  \includegraphics[height=4.in]{figures/ch3/cdt2}
}
\caption{Directory diagram of the schema of a Compact Trace Descriptor (CDT) file. On the left, we present a dissected flow, and on the right a set of flows.}
\label{fig:CTD-diagram}
\end{figure}

%3nd-review
\subsubsection{Flow features}


Some features are unique per flow and can be directly measured from the data. They are:  


\begin{itemize}
\item Flow-level properties like duration of flow, start delay, number of packets per flow, number of KBytes per flow; 
\item Header fields, like protocols, QoS fields, ports, and addresses.
\end{itemize}


Each one of these parameters is unique per flow. Other features like PSD (packet size distribution) e IPT (Inter-packet time), have a more complex behavior.  To represent these characteristics, we will use sets of stochastic-based models.  


%3nd-review
\subsubsection{Inter Packet Times}

\begin{figure*}[ht!]
    \centering
    \includegraphics[height=2.0in]{figures/ch3/modified-harpoon-model}
    \caption{The schema of the modified version of the Harpoon algorithm we adopt on SCIMITAR.}
    \label{fig:modified-harpoon-model}
\end{figure*}

To represent inter packet times, we adopt a simplified version of the Harpoon traffic model. A deep explanation of the original model can be found at \cite{harpoon-paper} and \cite{harpoon-validation}. Here, we will explain our simplified version, which is illustrated at figure~\ref{fig:modified-harpoon-model}. 


Harpoon uses a definition of each level, based on the measurement of SYN and ACK TCP flags. It use TCP flags (SYN) to classify packets in different levels, named there file, session, and user level. We choose to estimate these values, based on inter-packet times only. The distinction is made based on the time delay between packets.


In our algorithm simplified version, we define (as Harpoon does) three different layers of data transference to model and control: file, session, and flow. For SIMITAR, a file is just a sequence of consecutive packets transmitted continuously, without large interruption of traffic. It can be, for example, packets transmitted downloading a file, of UDP packets of a connection or a single ICMP echo packet. The session-layer refers to a sequence of multiple files transmitted between a source and a destination, belonging to the same flow.  And the flow level refers to the conjunct of flows, as classified by the Sniffer.  Now, we explain SIMITAR operation on each layer. All contants and defaults mode of operation can be changed by command line options.


In the \textbf{flow layer} the \textit{TraceAnalyzer} loads the flow arrival times from the database, and calculates the inter-packet times within the flow context. 


At the \textbf{session layer}, we use a deterministic approach for evaluating file tranference time and times between files: ON/OFF times sequence of packet trains. We choose a deterministic model because in this way we can express diurnal behavior\cite{harpoon-paper}.  We develop an algorithm called \textit{calcOnOff} responsible for estimating these times. It also determines the number of packets and bytes transferred by each file. Since the ON times will serve as input for actual traffic generators, we defined a minimum acceptable time for on periods equals to 100 ms. ON times can be arbitrary smalls, and they could be incompatible with acceptable ON periods for traffic generators and in the case of just one packet, the ON time would be zero. So setting aminimum acceptable time solve these issues. The OFF times, on the other hand, are defined by the constant \texttt{session\_cut\_time} \footnote{In the code it is called \texttt{DataProcessor::m\_session\_cut\_time} }. If the time between packets of the same flow is larger than this, we consider it belonging to a different file, so it is a Session OFF time. In this case, we use the same value of the constant \textit{Request and Response timeout} of Swing\cite{swing-paper} for the \texttt{session\_cut\_time}: 30 seconds. The control of ON/OFF periods in the traffic generation is made by the \textit{FlowGenerator} component \footnote{This control is made by the class \texttt{NetworkFlow}}.

%2nd-review
In the \textbf{file layer}, we model the inter-packet times at the file level. To estimate inter-packet times within files, we select all inter-packet times smaller than \texttt{session\_cut\_time}\footnote{In the code it is called\texttt{DataProcessor::m\_session\_cut\_time} }. All files within the same flow are considered to follow the same model. We delegate the control of the inter-packet times to the underlying workload engine tool. We ordered them, from the best to the worst. Currently, we are using eight different stochastic functions parameterizations. They are Weibull(linear regression), Normal(mean/standard deviation calculation), Exponential(mean and linear regression estimation), Pareto(linear regression and maximum likelihood), Cauchy(linear regression) and Constant(mean calculation). From those, Weibull, Pareto, and Cauchy are heavy-tailed functions, and therefore self-similar processes. But if the flow has less than 30 packets, just the constant model is evaluated. It is because numerical methods gave poor results if the data sample used is small. We sort these models according to the Akaike Information Criterion (AIC) as default\cite{sourcesonoff-paper}\cite{bic-aic-comparision}. We will enter in deeper details on this methodology on the chapter ~\ref{ch:modeling-evaluation}. The methodology of selection is presented in the figure~\ref{fig:model-parameterization}

%2nd-review
\begin{figure*}[ht!]
    \centering
    \includegraphics[height=0.9in]{figures/ch3/simitar-parametrization}
    \caption{Diagram of parameterization and model selection for inter-packet times and inter-file times.}
    \label{fig:model-parameterization}
\end{figure*}

%\begin{figure*}[ht!]
%    \centering
%    \includegraphics[height=4.0in]{figures/ch3/alg-paremeterization}
%    \caption{caption.}
%    \label{fig:harpoon-alg-times-estimator}
%\end{figure*}

\subsubsection{Packet Sizes}

%2nd-review
Our approach for the packet size is much simpler. Since the majority of packet size distribution found on real measurements are bi-modal \cite{packet-distribution-model}\cite{sourcesonoff-paper}\cite{udp-flows-model}, we first sort all packet sizes of flow in two modes. We define a packet size mode cut value of 750 bytes, same value adopted by \cite{udp-flows-model}. 

%2nd-review
We know how much packets each mode has, and then we fit a model for it. We use three stochastic models: constant, exponential and normal. Since self-similarity do not make sense for packet-sizes, we prefer to use just the simpler models. When there is no packet for a model, we set a flag NO\_MODEL, and when there is just a single packet we just use the constant model. Then calculate the BIC and AIC for each, but we decide to set the constant model as the first.

As is possible to see in many works \cite{packet-distribution-model} \cite{udp-flows-model}, since the standard deviation of each mode tends to be small, constant fittings use to give good approximations. Also, it is computationally cheaper for the traffic generated than the other models, since no calculation is a need for each packet sent. Since both AIC and BIC criteria always will select the constant model as the worst, we decide to ignore this

\subsubsection{Compact Trace Descriptor}

%2nd-review
An example of the final result of all the methods is presented in the XML code down below. It illustrates a flow of a \textit{Compact Trace Descriptor}(CDT) file. The traffic models for inter-packet times are grouped by the tag \texttt{inter\_packet\_times}, and the packet trains by the tag \texttt{session\_times}. All the times are in seconds, and \texttt{inf} represents infinity. The protocol of each layer is stored as data by each tag.

\begin{minted}[frame=single,
               framesep=3mm,
               linenos=true,
               xleftmargin=21pt,
               tabsize=4,
               fontsize=\scriptsize, 
               breaklines=true]{xml}
               
	<flow start_delay="0.144400" duration="317.744333" ds_byte="0" n_kbytes="40" n_packets="344">
		<link_layer mac_src="64:1c:67:69:51:bb" mac_dst="70:62:b8:9b:3e:d1">ETHERNET</link_layer>
		<network_layer src_ip="192.168.1.1" dst_ip="192.168.1.2" ttl="64">IPV4</network_layer>
		<transport_layer dst_port="2128" src_port="53">UDP</transport_layer>
		<application_layer>DNS</application_layer>
		<inter_packet_times>
			<stochastic_model name="pareto-ml" aic="-1165.310696" bic="-1157.646931" param1="0.405085202535192" param2="0.002272655895996"/>
			<stochastic_model name="pareto-lr" aic="-454.049749" bic="-446.385984" param1="0.061065000000000" param2="0.002272655895996"/>
			<stochastic_model name="weibull" aic="-246.882037" bic="-239.218273" param1="0.120355000000000" param2="0.001629000000000"/>
			<stochastic_model name="exponential-me" aic="486.370061" bic="494.033826" param1="1.340057495455104" param2="0.000000000000000"/>
			<stochastic_model name="normal" aic="1629.370900" bic="1637.034665" param1="0.746236637899171" param2="2.626808289821357"/>
			<stochastic_model name="exponential-lr" aic="3166.816047" bic="3174.479812" param1="0.009752000000000" param2="0.000000000000000"/>
			<stochastic_model name="cauchy" aic="31737.418442" bic="31745.082207" param1="0.000000000000194" param2="-3152.827055696396656"/>
			<stochastic_model name="constant" aic="inf" bic="inf" param1="0.746236637899171" param2="0.000000000000000"/>
		</inter_packet_times>
		<session_times on_times="29.22199798,73.40390396,151.84077454" off_times="30.85738373,32.42027283" n_packets="19,103,222" n_bytes="2272,12399,26689"/>
		<packet_sizes n_packets="344" n_kbytes="40">
			<ps_mode1 n_packets="344" n_kbytes="40">
				<stochastic_model name="constant" aic="inf" bic="inf" param1="120.232558" param2="0.000000"/>
				<stochastic_model name="normal" aic="2926.106952" bic="2933.788235" param1="120.232558" param2="16.941453"/>
				<stochastic_model name="exponential-me" aic="3987.126362" bic="3994.807645" param1="0.008317" param2="0.000000"/>
			</ps_mode1>
			<ps_mode2 n_packets="0" n_kbytes="0">
				<stochastic_model name="no-model-selected" aic="inf" bic="inf" param1="0.000000" param2="0.000000"/>
			</ps_mode2>
		</packet_sizes>
	</flow>
	
\end{minted}

%2nd-review
%The current version of our tool, do not intrinsically supports responsiveness. The underlying traffic generator API can support it (such as Seagull\cite{web-seagull}), but we do not generate any mathematical model for this purpose, and this may also stand as a future work we discuss on chapter ~\ref{ch:conclusion}. 

\subsection{Flow Generator}

\begin{figure*}[ht!]
    \centering
    \includegraphics[height=4.5in]{figures/ch3/alg-simplified-harpoon}
    \caption{Simplified-harpoon emission algorithm}
    \label{fig:alg-simplified-harpoon}
\end{figure*}

The Flow Generator handles the data on the CTD file, and use to retrieve parameters for traffic generation. It crafts and controls each flow in a separated thread. 

%2nd-review
We first implemented it using the D-ITG API. But our Flow Generator can use any traffic generator with API, CLI or script interface as well. To easily expand this component, we use the design pattern factory. If the user wants to introduce support for a new traffic generator, he just has to expand the class \texttt{DummyFlow} and add the support on the method \texttt{make\_flow()} of the class \texttt{NetworkFlow}. We will discuss this deeper in the next section.

%2nd-review
This component works in two different layers according to the traffic generators classification introduced in the chapter ~\ref{ch:literature-review}: at the Flow level, and packet level, as presented in the figure ~\ref{fig:layers-workload-tools}. 

\begin{figure*}[ht!]
    \centering
    \includegraphics[height=4.0in]{figures/ch3/alg-traffic-engine-config}
    \caption{Traffic engine configuration model}
    \label{fig:alg-traffic-engine-config}
\end{figure*}

\subsubsection{Flow-level Traffic Generation Operation}

%2nd-review
At the flow level, it controls each flow using the algorithm at figure~\ref{alg-simplified-harpoon}. This algorithm basically handles the our model defined at the figure~\ref{fig:modified-harpoon-model}.

%2nd-review
It starts a \textit{thread} for each flow in the \textit{Compact Trace Descriptor}, then the thread sleeps its \texttt{start\_delay}. It is the time when the first flow packet was captured in the original capture. it then calls the underlying traffic generation method, passing to it the file ON time, number of packets and number of bytes to be sent (file size). Then it sleeps the next Session-OFF time from the stack until it ends. When the list of ON/OFF times is over, the thread ends. The thread scheduling/joining is implemented by the class \texttt{NetworkTrace} and its sleep/wake process by the class \texttt{DummyFlow}.


\subsubsection{Flow Generation Programming}

%2nd-review
At the packet level, it must use the expanded class of the \texttt{DummyFlow}. In this level, the job of our tool is to configure the underlying engine, to send a file. Therefore it uses the \textit{getters} available, and the passed parameters, defined by the operation described in the previous session. The implementation of this level should follow the flowchart presented in the figure ~\ref{fig:alg-traffic-engine-config}.
Down below we present a simplistic code of how the D-ITG API can be used to generate packet-level traffic. We call this concept \textit{Flow Generation Programming} A more complex configuration is possible, but it serves to illustrate the procedure. Its API documentation is available at on D-ITG web-site \footnote{\href{http://www.grid.unina.it/software/ITG/manual/index.html\#SECTION00047000000000000000}{http://www.grid.unina.it/software/ITG/manual/index.html\#SECTION00047000000000000000}}. 
\begin{minted}[frame=single,
               framesep=3mm,
               linenos=true,
               xleftmargin=21pt,
               tabsize=4,
               fontsize=\scriptsize, 
               breaklines=true]{c++}
void flowGenerate(const counter& flowId, const time_sec& onTime, const uint& npackets, const uint& nbytes,  const string& netInterface)
{
	char localhost[CHAR_BUFFER];
	string strCommand;
	char command[CHAR_BUFFER];
	uint i = 0;
	int rc = 0;
	getLocalIp("eth0", localhost);
	strCommand += " -t " + std::to_string(onTime); 
	strCommand += " -k " + std::to_string(nbytes / 1024);
	strCommand += " -a " + getHostIP();
	if (this->getTransportProtocol() == PROTOCOL__TCP)
		strCommand += " -T TCP -D ";
	else if (this->getTransportProtocol() == PROTOCOL__UDP)
		strCommand += " -T UDP ";
	else if (this->getTransportProtocol() == PROTOCOL__ICMP)
		strCommand += " -T ICMP ";
	for(;;i++)
	{	
		StochasticModelFit idtModel = this->getInterDepertureTimeModel(i);
		if(idtModel.modelName() == WEIBULL)
		{
			strCommand += " -W " + std::to_string(idtModel.param1()) + " " + std::to_string(idtModel.param2());
			break;
		}
		else if ( idtModel.modelName() == CONSTANT)
		{
			strCommand += " -C " + std::to_string(nbytes/(1024*onTime));
			break;
		}
	}
	strcpy(command, strCommand.c_str());
	rc = DITGsend(localhost, command); // it is not blocking
    usleep(onTime*10e6);
	if (rc != 0)
	{
		printf("\nDITGsend() return value was %d\n", rc);
		exit(EXIT_FAILURE);
	}
}
\end{minted}

\subsection{Network Traffic Generator}


A network traffic generator software that should provide its API or script interface for the \textit{FlowGenerator} component. 
 
Since \texttt{DITGsend()} is thread safe, no mutex is need. It would be needed if a lower level API, such Libtins or Libpcap was used. In that case, these APIs would permit control precisely each packet sent through the interface, but a mutex would be necessary. An scriptable tool, such as Iperf can be used as well, using \texttt{fork()} or \texttt{popen()}.

As we claimed before, this tools is simple of being expanded for almost any traffic generation API, since its modeling framework is not coupled to the traffic generation.
The figure \ref{fig:network-trace-flow-class-diagram} illustrates it well. It presents three possibilities of different traffic generation engines, all being configured and scheduled in a platform-agnostic way.

\begin{figure*}[ht!]
    \centering
    \includegraphics[height=3.0in]{figures/ch3/trace-flow}
    \caption{Class hierarchy of NetworkTrace and NetworkFlow, which enables the abstraction of the traffic generation model of the traffic generation engine.}
    \label{fig:network-trace-flow-class-diagram}
\end{figure*}


\section{Usage and Use Cases}

Each SIMITAR component works as a different application:

\begin{itemize}
	\item \texttt{sniffer-cli.py};
	\item \texttt{trace.db} (sqlite3 database);
	\item \texttt{trace-analyzer}.
	\item \texttt{simitar-gen} (traffic generator).
\end{itemize}


When it working as a sniffer, it strores data from the capture traffic in the sqlite3 database. It may work over a \textit{pcap} file or an Ethernet interface. Working as a trace a trace-analyzer, it receive the name of the trace as stored in the database, and creates a XML compact trace descriptor. The constants used in the modelling may be changed and provided as command line argument. If not, the default values will be used. 

As a traffic generator it may work as a client or a server. Working as a server is necessary for tools that require establishing a connection before generate the traffic, such as Iperf and D-ITG. It will just work passivaly. Working as a client, is acts as a traffic emissor. Tools such as \textit{libtins} dos not require server operation the send the traffic. 

When it operates as a client or as packet injector, it is operating as a traffic generator. The difference is that as a client, the used traffic generator is connection-oriented. It needs to establish a connection with the destination host (the server), before start sending packets. Operating as a client, it must take as an input a list of IP or MAC destination addresses, since they will not match with the ones in the original trace. It takes as an input a single destination in the command line, or list of many, in a text file passes as a parameter. Also, it uses the machine IP address as packet's source IP.

 As a packet injector can generate packets on the output interface, without establishing a connection. It uses the original IP and MAC destination and source addresses. As a client, the reproduction of the trace is expected to be poor in the flow level metrics exposed in the chapter ~\ref{ch:literature-review}, since it will use new addresses values. 

The operation of packet injector is still under implementation, and we are using Libtins API. Currently, SIMITAR supports client mode with D-ITG, implemented using its C++ API. We intend to provide support for many others traffic generators, such Iperf and Ostinato.

When operating as a server, it just start-up the traffic generator server, and waits forclient requests for connections. Down bellow, we present simple examples of commands used to activate each operation mode.

\begin{minted}[frame=single,
               framesep=3mm,
               linenos=true,
               xleftmargin=21pt,
               tabsize=4,
               fontsize=\scriptsize, 
               breaklines=true]{bash}

# @ SIMITAR/, load enviroment variables
source data/config/simitar-workspace-config.sh

# @ SIMITAR/sniffer/, execute to sniffer the eth0 interface, and create a trace entry called "intrig" in the database
./sniffer-cli.py new intrig live eth0

# @ SIMITAR/sniffer/, execute this command to list all traces recorded in the database
./sniffer-cli.py list

# @ SIMITAR/trace-analyzer/, execute this command to create two Compact Trace Descriptors, called intrig.ms.xml and intrig.sec.xml. The first is parameterized using milisecons, and de second, uses seconds as time unity.
./trace-analyzer --trace intrig

# @ SIMITAR/simitar-gen/, execute these commands to generate traffic using the intrig.sec.xml compact trace descriptor. It is stored at the directory "../data/xml/". 
# Libtins
./simitar-gen --tool tins --mode client --ether eth0 --xml ../data/xml/intrig.sec.xml 
# Iperf
./simitar-gen --tool iperf --mode client --ether eth0 --xml ../data/xml/intrig.sec.xml --dst-ip 10.0.0.2
./simitar-gen --tool iperf --mode server --ether eth0 --xml ../data/xml/intrig.sec.xml

\end{minted}

As use cases, we can cite:

\begin{itemize}

\item Flow Generation Progamability: creation of custom synthetic traffic with a certain number of flows, in a traffic-generator independent way.

\item Generate Background traffic with D-ITG: SIMITAR can work to generate background traffic over a network when it receives many addresses as input. If each destination is reachable, D-ITG will establish a connection with each destination, and recreate flows as described in the CDT file. 

\item Stress a Device Under Test (DUT): It can be used to stress a single device with a more self-similar realistic traffic. The CDT file can be manually modified to change some aspects of the traffic, such as the number os packets or throughput applied by the traffic generator of each flow. Some undesirable features such as Stochastic models or lesser flow may be taken out, SIMITAR does not have constraints on a number of flows and Stochastic models adopted (but must have at least one).

\item Generate synthetic \textit{pcap} files: Using virtual interfaces, we can reproduce a traffic, and capture it with a sniffer tool, such as Tcpdump, Wireshark or Tshark. We plan to automatize this process as a future work, with an operation mode of \textit{pcap} generator. To do this we are going to use Mininet to create the virtual interfaces and Libtins to inject packets.

\end{itemize}




