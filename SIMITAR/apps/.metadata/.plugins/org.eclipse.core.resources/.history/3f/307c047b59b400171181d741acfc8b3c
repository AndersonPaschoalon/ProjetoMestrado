/*
 * TinsFlow.cpp
 *
 *  Created on: 3 de out de 2017
 *      Author: anderson
 */

#include "TinsFlow.h"

TinsFlow::TinsFlow()
{
}

TinsFlow::~TinsFlow()
{
}

int TinsFlow::server()
{
	printf("TODO: libtins server\n");
	return(0);
}

void TinsFlow::flowGenerate(const counter& flowId, const time_sec& onTime,
		const uint& npackets, const uint& nbytes, const string& netInterface)
{

	uint npackets_mode1 = (uint) this->getNpacketsMode1();
	uint npackets_mode2 = (uint) this->getNpacketsMode2();
	uint packetSize_mode1 = (uint) this->getPacketSizeModelMode1(0).param1();
	uint packetSize_mode2 = (uint) this->getPacketSizeModelMode2(0).param1();

	this->sendPackets(getLinkProtocol(), getNetworkProtocol(),
			getTransportProtocol(), getApplicationProtocol(), getMacSrcAddr(),
			getMacDstAddr(), getNetworkSrcAddr(), getNetworkDstAddr(),
			getNetworkTtl(), getTransportSrcPort(), getTransportDstPort(),
			npackets_mode1, packetSize_mode1, netInterface);
	this->sendPackets(getLinkProtocol(), getNetworkProtocol(),
			getTransportProtocol(), getApplicationProtocol(), getMacSrcAddr(),
			getMacDstAddr(), getNetworkSrcAddr(), getNetworkDstAddr(),
			getNetworkTtl(), getTransportSrcPort(), getTransportDstPort(),
			npackets_mode2, packetSize_mode2, netInterface);
}

void TinsFlow::sendPackets(protocol etherProtocol, protocol netProtocol,
		protocol transportProtocol, protocol application, std::string etherSrc,
		std::string etherDst, std::string netSrc, std::string netDst,
		uint ttlNumber, uint portSrc, uint portDst, uint npackets, uint pktSize,
		std::string networkInterface)
{
	/// Packet crafter
	PDU* flowPkt;
	PacketSender::SocketType socket_type;
	if (etherProtocol == PROTOCOL__ETHERNET)
	{
		if (netProtocol == PROTOCOL__IPV4)
		{
			if (transportProtocol == PROTOCOL__TCP)
			{
				if (application == PROTOCOL__DHCP)
				{

					flowPkt = new EthernetII() / IP(netDst, netDst)
							/ TCP(portDst, portSrc) / DHCP()
							/ RawPDU(std::string(pktSize, 'H'));

				}
				else if (application == PROTOCOL__DNS)
				{

					flowPkt = new EthernetII() / IP(netDst, netDst)
							/ TCP(portDst, portSrc) / DNS()
							/ RawPDU(std::string(pktSize, 'D'));
				}
				else
				{
					flowPkt = new EthernetII() / IP(netDst, netDst)
							/ TCP(portDst, portSrc)
							/ RawPDU(std::string(pktSize, 'T'));
				}
				socket_type = PacketSender::IP_TCP_SOCKET;

			}
			else if (transportProtocol == PROTOCOL__UDP)
			{
				if (application == PROTOCOL__DHCP)
				{
					flowPkt = new EthernetII() / IP(netDst, netDst)
							/ UDP(portDst, portSrc) / DHCP()
							/ RawPDU(std::string(pktSize, 'H'));
				}
				else if (application == PROTOCOL__DNS)
				{
					flowPkt = new EthernetII() / IP(netDst, netDst)
							/ UDP(portDst, portSrc) / DNS()
							/ RawPDU(std::string(pktSize, 'D'));
				}
				else
				{
					flowPkt = new EthernetII() / IP(netDst, netDst)
							/ UDP(portDst, portSrc)
							/ RawPDU(std::string(pktSize, 'U'));
				}
				socket_type = PacketSender::IP_UDP_SOCKET;
			}
			else if (transportProtocol == PROTOCOL__ICMP)
			{
				flowPkt = new EthernetII() / IP(netDst, netDst) / ICMP()
						/ RawPDU(std::string(pktSize, 'I'));
				socket_type = PacketSender::ICMP_SOCKET;
			}
		}
		else if (netProtocol == PROTOCOL__IPV6)
		{
			if (transportProtocol == PROTOCOL__TCP)
			{
				if (application == PROTOCOL__DHCP)
				{

					flowPkt = new EthernetII() / IPv6(netDst, netDst)
							/ TCP(portDst, portSrc) / DHCP()
							/ RawPDU(std::string(pktSize, 'H'));
				}
				else if (application == PROTOCOL__DNS)
				{

					flowPkt = new EthernetII() / IPv6(netDst, netDst)
							/ TCP(portDst, portSrc) / DNS()
							/ RawPDU(std::string(pktSize, 'D'));
				}
				else
				{
					flowPkt = new EthernetII() / IPv6(netDst, netDst)
							/ TCP(portDst, portSrc)
							/ RawPDU(std::string(pktSize, 'T'));
				}
			}
			else if (transportProtocol == PROTOCOL__UDP)
			{
				if (application == PROTOCOL__DHCP)
				{

					flowPkt = new EthernetII() / IPv6(netDst, netDst)
							/ UDP(portDst, portSrc) / DHCP()
							/ RawPDU(std::string(pktSize, 'h'));
				}
				else if (application == PROTOCOL__DNS)
				{

					flowPkt = new EthernetII() / IPv6(netDst, netDst)
							/ UDP(portDst, portSrc) / DNS()
							/ RawPDU(std::string(pktSize, 'd'));
				}
				else
				{
					flowPkt = new EthernetII() / IPv6(netDst, netDst)
							/ UDP(portDst, portSrc)
							/ RawPDU(std::string(pktSize, 'u'));
				}
			}
			else if (transportProtocol == PROTOCOL__ICMP)
			{

				flowPkt = new EthernetII() / IPv6(netDst, netDst) / ICMPv6()
						/ RawPDU(std::string(pktSize, 'i'));
			}
			socket_type = PacketSender::IPV6_SOCKET;

		}
		else if (etherProtocol == PROTOCOL__ARP)
		{
			//flowPkt = new ARP() / RawPDU(std::string(pktSize, 'a'));
			flowPkt = new EthernetII() / ARP();
			socket_type = PacketSender::ARP_SOCKET;
		}
		else
		{
			flowPkt = new EthernetII() / RawPDU(std::string(pktSize, 'x'));
			socket_type = PacketSender::ETHER_SOCKET;
		}
	}

	/// Packet sender
	PacketSender sender;
	NetworkInterface iface(networkInterface);

	sender.open_l2_socket(networkInterface);
	sender.open_l3_socket(socket_type);
	std::cout << std::endl;
	for (uint i = 0; i < npackets; i++)
	{
		sender.send(*flowPkt, iface);
		std::cout << i << ", ";
	}
	std::cout << endl;
	sender.close_socket(socket_type, networkInterface);

	/// Free memory
	delete flowPkt;
}
