/*
 * DitgFlow.cpp
 *
 *  Created on: 15 de set de 2017
 *      Author: anderson
 */

#include "DitgFlow.h"

DitgFlow::DitgFlow()
{
	// TODO Auto-generated constructor stub

}

DitgFlow::~DitgFlow()
{
	// TODO Auto-generated destructor stub
}

int DitgFlow::server()
{
	return 0;
}

void DitgFlow::flowGenerate(const counter& flowId, const time_sec& onTime,
		const uint& npackets, const uint& nbytes, const string& netInterface)
{
}

std::string DitgFlow::ditg_command(const time_sec& onTime, const uint& npackets,
		const uint& nbytes, const string& netInterface)
{
	std::string strCommand = "ITGSend ";




	/***************************************************************************
	 * D-ITG settings parser
	 **************************************************************************/

	/**
	 * Flow-level settings
	 */
	int fileTimeout = int(this->getFlowDuration() * 1000);
	//duration
	if (fileTimeout == 0)
		fileTimeout = 1;
	strCommand += " -t " + std::to_string(fileTimeout);
	//DS byte
	strCommand += " -b " + std::to_string(this->getFlowDsByte());
	//Guarantee the mean packet rate
	strCommand += " -j 1";

	/**
	 * Network-layer settings
	 */
	//tty byte
	strCommand += " -f " + std::to_string(this->getNetworkTtl());
	//destination and sources IPv4/IPv6 address
	strCommand += " -a " + this->getNetworkDstAddr();
	strCommand += " -sa " + this->getNetworkSrcAddr();

	/**
	 * Transport-layer settings
	 */
	if (this->getTransportProtocol() == PROTOCOL__TCP)
	{
		strCommand += " -T TCP -D ";
		strCommand += " -rp " + std::to_string(this->getTransportDstPort());
		strCommand += " -sp " + std::to_string(this->getTransportSrcPort());
	}
	else if (this->getTransportProtocol() == PROTOCOL__UDP)
	{
		strCommand += " -T UDP ";
		strCommand += " -rp " + std::to_string(this->getTransportDstPort());
		strCommand += " -sp " + std::to_string(this->getTransportSrcPort());
	}
	else if (this->getTransportProtocol() == PROTOCOL__ICMP)
	{
		//TODO set ICMP type
		strCommand += " -T ICMP ";
	}
	else if (this->getTransportProtocol() == PROTOCOL__SCTP)
	{
		//TODO Set D-ITG compile file to support SCTP
		// To enable this option D-ITG has to be compiled with"sctp" option enabled (i.e.  make sctp=on).
		strCommand += " -T SCTP "
				+ std::to_string(this->getTransportSctpAssociationId()) + " "
				+ std::to_string(this->getTransportSctpMaxStreams()) + " ";
	}
	else if (this->getTransportProtocol() == PROTOCOL__DCCP)
	{
		//TODO Set D-ITG compile file to support DCCP
		//To enable this option D-ITG has to be compiled with "dccp" option enabled (i.e.  make dccp=on).
		strCommand += " -T DCCP ";
	}
	else
	{
		strCommand += " -T UDP -rp " + std::to_string(this->randTranportPort());
	}


	/**
	 * Inter-departure time options
	 */
	for(int i = 0;;i++)
	{
		StochasticModelFit idtModel = this->getInterDepertureTimeModel(i);

		if (idtModel.modelName() == WEIBULL)
		{
			//idtModel.param1 = alpha (shape)
			//idtModel.param2 = betha (scale)
			strCommand += " -W " + std::to_string(idtModel.param1()) + " "
					+ std::to_string(idtModel.param2());
			break;
		}
		else if (idtModel.modelName() == NORMAL)
		{
			//idtModel.param1 = mu (shape)
			//idtModel.param2 = sigma dev
			strCommand += " -N " + std::to_string(idtModel.param1()) + " "
					+ std::to_string(idtModel.param2());
			break;
		}
		// TODO exponetial uses mean
		//else if (idtModel.modelName() == EXPONENTIAL_MEAN)
		//{
		//	//idtModel.param1 = mean
		//	strCommand += " -E " + std::to_string(idtModel.param1());
		//	break;
		//}
		// TODO exponetial uses mean
		//else if (idtModel.modelName() == EXPONENTIAL_LINEAR_REGRESSION)
		//{
		//	//idtModel.param1 = mean
		//	strCommand += " -E " + std::to_string(idtModel.param1());
		//	break;
		//}
		/// Pareto Maximum likehood has horrible results
		//else if ( idtModel.modelName() == PARETO_MAXIMUM_LIKEHOOD)
		//{
		//	//idtModel.param1 = alpha (shape)
		//	//idtModel.param2 = xm (scale)
		//	strCommand += " -V " + std::to_string(idtModel.param1()) + " "
		//			+ std::to_string(idtModel.param2());
		//	break;
		//}
		else if (idtModel.modelName() == PARETO_LINEAR_REGRESSION)
		{
			//idtModel.param1 = alpha (shape)
			//idtModel.param2 = xm (scale)
			strCommand += " -V " + std::to_string(idtModel.param1()) + " "
					+ std::to_string(idtModel.param2());
			break;
		}
		else if (idtModel.modelName() == CAUCHY)
		{
			//idtModel.param1 = gamma (scale)
			//idtModel.param2 = xm (shape - location)
			strCommand += " -Y " + std::to_string(idtModel.param2()) + " "
					+ std::to_string(idtModel.param1());
			break;
		}
		else if (idtModel.modelName() == CONSTANT)
		{
			strCommand += " -C " + std::to_string(idtModel.param1());
			break;
		}
	}

	}


	return(strCommand);
}


