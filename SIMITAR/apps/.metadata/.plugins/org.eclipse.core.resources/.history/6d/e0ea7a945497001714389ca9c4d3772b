/*
 * IperfFlow.cpp
 *
 *  Created on: 11 de set de 2017
 *      Author: anderson
 */

#include "IperfFlow.h"

IperfFlow::IperfFlow()
{
	// TODO Auto-generated constructor stub

}

IperfFlow::~IperfFlow()
{
	// TODO Auto-generated destructor stub
}

int IperfFlow::server()
{
	// popen args
	FILE *in;
	char buff[512];
	//iperf args

	char command[2048] = "iperf -s";

	if (!(in = popen(command, "r")))
	{
		return 1;
	}

	while (fgets(buff, sizeof(buff), in) != NULL)
	{
		network_flow_iostream_mutex.lock();
		std::cout << buff;
		network_flow_iostream_mutex.unlock();
	}

	pclose(in);
}

void IperfFlow::flowGenerate(const counter& flowId, const time_sec& onTime,
		const uint& npackets, const uint& nbytes, const string& netInterface)
{
	// popen args
	FILE *in;
	char buff[512];
	//iperf args

	char command[2048];
	strcpy(command,
			iperf_command(onTime, npackets, nbytes, netInterface).c_str());

	if (!(in = popen(command, "r")))
	{
		std::cerr << "IperfFlow error: cannot execute command `" << command << "`" << std::endl;
	}

	while (fgets(buff, sizeof(buff), in) != NULL)
	{
		network_flow_iostream_mutex.lock();
		std::cout << buff;
		network_flow_iostream_mutex.unlock();
	}

	pclose(in);
}

std::string IperfFlow::iperf_command(const time_sec& onTime,
		const uint& npackets, const uint& nbytes, const string& netInterface)
{
	/// iperf running options. Traffic generation custom options
	enum_transmission_type transmission_type = on_time;
	std::string congestion_algorithm_name = "reno";
	bool real_time = true;
	bool congestion_algorithm = true;
	bool no_delay = true;

	/// Simitar values. Values captured form the compact trace descriptor
	int bw = this->getNumberOfKbytes() * 8 / onTime;
	int pps = this->getNumberOfPackets() / onTime;

	int nkbytes = this->getNumberOfKbytes();
	int nkbits = this->getNumberOfKbytes() * 8;
	int ttlVal = this->getNetworkTtl();
	bool tcp = (this->getTransportProtocol() == PROTOCOL__TCP) ? true : false;
	bool ipv6 = (this->getNetworkProtocol() == PROTOCOL__IPV6) ? true : false;
	std::string server_ip = this->getNetworkDstAddr();
	std::string client_ip = this->getNetworkSrcAddr();
	uint tranport_port = this->getTransportDstPort();
	std::string format = "k"; // format to report: kbits, mbits, KBytes, MBytes

	/// Iperf config opts. Iperf command options
	std::string opt_bandwidth;
	std::string opt_tranmission;
	if (transmission_type == on_time)
	{
		opt_tranmission = " --time " + std::to_string(onTime);
		opt_bandwidth = " --bandwidth " + std::to_string(bw) + "k";
	}
	else if (transmission_type == bits)
	{
		opt_tranmission = " --time " + std::to_string(onTime);
		opt_bandwidth = " --bandwidth " + std::to_string(bw) + "k";
	}
	else // transmission_type == packets
	{
		opt_tranmission = " --num " + std::to_string(npackets);
		opt_bandwidth = " --bandwidth " + std::to_string(npackets / onTime)
				+ "pps";
	}
	std::string opt_format = " --format k "; // format to report: Kbits, Mbits, KBytes, MBytes
	std::string opt_transport_protocol = (tcp == true) ? "" : " --udp ";
	std::string opt_transport_port = std::string(" --bind ") + client_ip
			+ std::string(":") + std::to_string(tranport_port);
	std::string opt_real_time = (real_time == true) ? " --realtime " : "";
	std::string opt_nodelay = " --nodelay ";
	std::string opt_congestion_algorithm =
			(congestion_algorithm == true) ?
					std::string(" --linux-congestion ")
							+ congestion_algorithm_name :
					"";
	std::string opt_ipv6 = (ipv6 == true) ? " --ipv6_domain " : "";
	std::string opt_ttl = " --ttl " + std::to_string(ttlVal);
	std::string opt_no_delay = (no_delay == true) ? " --nodelay " : "";

	/// iperf command
	std::string command_client = std::string("iperf -c ") + server_ip
			+ opt_bandwidth + opt_tranmission + opt_format
			+ opt_transport_protocol + opt_transport_port + opt_real_time
			+ opt_nodelay + opt_congestion_algorithm + opt_ipv6 + opt_ttl
			+ opt_no_delay;

	return (command_client);
}
