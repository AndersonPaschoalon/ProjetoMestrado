//============================================================================
// Name        : Main.cpp
// Author      : Anderson Paschoalon
// Version     :
// Copyright   : Your copyright notice
// Description : Trace Analyzer SIMITAR component, Ansi-style
//============================================================================

// Deps
#include <string>
#include <iostream>
#include <algorithm>
#include <tclap/CmdLine.h>
#include <vector>
// Simitar
#include <PlogMacros.h>
#include <DatabaseInterface.h>
#include <TraceDbManager.h>
#include <DataProcessor.h>
#include <DummyFlow.h>
#include <NetworkTrace.h>
#include <Defines.h>
#include <Protocol.h>
#include <cfunctions.h>
#include <SimitarWorkspace.h>

void cli_error_messege(std::string arg, std::string arg_name,
		std::string expected_values);

bool cli_check_val(std::string val, std::vector<std::string> expectedVals);

int main(int argc, char** argv)
{
	PLOG_INIT_TXT(verbose);
	try
	{
		// msgs
		char progDescription[] =
				"SIMITAR trace-analyzer component. It take as input a measured trace from sniffer, \
and generate a Compact Trace Descriptor in the XML format. The Compact Trace Descriptor files are \
stored inside the SIMITAR workspace in the directory `data/xml/`, and may be edited manually. ";

		// version
		char version[CHAR_BUFFER];
		SimitarWorkspace workspace = SimitarWorkspace();
		std::string str_version = workspace.version_tag() + ":"
				+ workspace.version_name();
		strcpy(version, str_version.c_str());


		TCLAP::CmdLine cmd(progDescription, ' ', version);

		TCLAP::ValueArg<std::string> trace_arg("t", "trace",
				"Trace used to generate the Compact Trace Descriptor", true, "",
				"string");
		TCLAP::ValueArg<double> minon_arg("n", "min-on",
				"min_on_time constant used by the algorithm calcOnOff. Defines the minimum time of a packet train. Default: 0.1s",
				false, 0.1, "double");
		TCLAP::ValueArg<double> minoff_arg("f", "min-off",
				"sesssion_cut_time constant used by the algorithm calcOnOff. Defines the minimum OFF time between sessions. Default: 30.0s",
				false, 30.0, "double");
		TCLAP::ValueArg<std::string> criterion_arg("c", "criterion",
				"Criterion used to sort the stochastic models, `aic` or `bic`. Default: `aic`",
				false, "aic", "string");
		TCLAP::ValueArg<int> minpkts_arg("p", "min-pkts",
				"Minimum numbers of packets of a flow that will allow stochastic fitting. Flow with less packets will use just the constant model. Default: 30.",
				false, 30, "int");

		cmd.add(trace_arg);
		cmd.add(minon_arg);
		cmd.add(minoff_arg);
		cmd.add(criterion_arg);
		cmd.add(minpkts_arg);

		cmd.parse(argc, argv);

		std::string trace_name = trace_arg.getValue();
		double on_val = minon_arg.getValue();
		double off_val = minoff_arg.getValue();
		std::string crit_val = criterion_arg.getValue();
		int pkts_val = minpkts_arg.getValue();

		if (!cli_check_val(crit_val,
		{ "aic", "bic" }))
		{
			cli_error_messege(crit_val, "criterion", "`aic` or `bic`");
			return (-1);
		}

		if (workspace.database_version() == "1")
		{
			DatabaseInterface dbif = DatabaseInterface();
			NetworkTrace traceSec = NetworkTrace();
			NetworkTrace traceMs = NetworkTrace();

			DataProcessor dp = DataProcessor(seconds, on_val, off_val,
					pkts_val, crit_val);
			dp.calculate(trace_name, &dbif, &traceSec);
			traceSec.writeToFile(workspace.dir_xml() + "/" + ".sec" + ".xml");

			dp = DataProcessor(milliseconds, on_val, off_val,
					pkts_val, crit_val);
			dp.calculate(trace_name, &dbif, &traceMs);
			traceSec.writeToFile(workspace.dir_xml() + "/" + trace_name +".ms" + ".xml");
			PLOG_INFO << "TRACE ANALYZER FINALIZED SUCCESSEFULLY!";

		}
		else if (workspace.database_version() == "2")
		{
			PLOG_DEBUG << "Database version:" << workspace.database_v2();
			PLOG_DEBUG << "-- TraceDbManager";
			//TraceDbManager database = TraceDbManager(workspace.database_v2());
			//NetworkTrace traceSec = NetworkTrace();
			//NetworkTrace traceMs = NetworkTrace();

			TraceDbManager* database = new TraceDbManager(workspace.database_v2());
			NetworkTrace* traceSec = new NetworkTrace();
			NetworkTrace* traceMs = new NetworkTrace();
			string cdtFileName = "";

			// create a DDT file on seconds time-scale
			PLOG_DEBUG << "-- DataProcessor(seconds, on_val:" << on_val << ", off_val:" <<
					off_val << ", pkts_val:" << pkts_val << ", crit_val:" << crit_val << ")";
			DataProcessor* dp = new DataProcessor(seconds, on_val, off_val, pkts_val, crit_val);
			PLOG_DEBUG << "-- DataProcessor.calculate_v2";
			dp->calculate_v2(trace_name, database, traceSec);
			PLOG_DEBUG << "-- traceSec.writeToFile(" << workspace.dir_xml() << trace_name << ".sec.xml";
			cdtFileName = workspace.dir_xml() + "/" + trace_name + ".sec" + ".xml";
			traceSec->writeToFile(cdtFileName);
			printf("Compact Trace Descriptor {%s} created!\n", cdtFileName.c_str());
			delete dp;
			delete traceSec;
			dp = NULL;
			traceSec = NULL;

			// create a CDT on miliseconds time-scale
			PLOG_DEBUG << "-- DataProcessor(milliseconds, on_val:" << on_val << ", off_val:" <<
					off_val << ", pkts_val:" << pkts_val << ", crit_val:" << crit_val << ")";
			dp = new DataProcessor(milliseconds, on_val, off_val,
					pkts_val, crit_val);
			PLOG_DEBUG << "-- DataProcessor.calculate_v2";
			dp->calculate_v2(trace_name, database, traceMs);
			PLOG_DEBUG << "-- traceSec.writeToFile(" << workspace.dir_xml() << trace_name << ".ms.xml";
			traceMs->writeToFile(workspace.dir_xml() + "/" + trace_name + ".ms" + ".xml");

			delete database;
			delete dp;
			delete traceMs;
			database = NULL;
			dp = NULL;
			traceMs = NULL;
			PLOG_INFO << "TRACE ANALYZER FINALIZED SUCCESSEFULLY!";
		}

	} catch (TCLAP::ArgException &e)  // catch any exceptions
	{
		PLOG_ERROR << "trace-analyzer Error: " << e.error() << " for arg "
				<< e.argId();
		std::cerr << "trace-analyzer Error: " << e.error() << " for arg "
				<< e.argId() << std::endl;
	}

	return 0;
}

void cli_error_messege(std::string arg, std::string arg_name,
		std::string expected_values)
{
	std::cerr << "trace-analyzer Error: invalid argument " << arg << " for "
			<< arg_name << ". Expected " << expected_values
			<< ". Use --help for help." << std::endl;

}

bool cli_check_val(std::string val, std::vector<std::string> expectedVals)
{
	uint m = expectedVals.size();

	for (uint i = 0; i < m; i++)
		if (val == expectedVals[i])
			return (true);

	return (false);
}

