/*
 * StochasticModelFit.h
 *
 *  Created on: 6 de nov de 2016
 *      Author: apaschoalon
 */

#ifndef STOCHASTICMODELFIT_H_
#define STOCHASTICMODELFIT_H_

#include <cmath>
#include <cfloat>
#include <armadillo>
#include <string>
#include <string.h>

#include "Defines.h"
#include "MesserLog.h"

using std::string;
using namespace arma;
/**
 * This struct must only be generated by the method DataProcessor::fitModels()
 */
/*
 typedef struct stochastic_model_fitting
 {
 //AIC criterion value for the model
 double aic;

 //BIC criterion value for the model
 double bic;

 //String with a human-readable name of the current model
 string modelName;

 //first parameter (in alphabetical order) of the model
 double param1;

 //second parameter (in alphabetical order) of the model
 double param2;

 //Number of models setted by the method DataProcessor::fitModels()
 unsigned int size;

 } StochasticModelFit;
 */

//test
class StochasticModelFit
{
public:

	StochasticModelFit()
	{
		m_modelName = NO_MODEL;
		m_param1 = 0;
		m_param2 = 0;
		m_aic = datum::nan;
		m_bic = datum::nan;
	}

	double aic() const
	{
		return (m_aic);
	}
	double bic() const
	{
		return (m_bic);
	}
	string strModelName() const
	{
		string strRet;

		if (m_modelName == WEIBULL)
		{
			strRet = "weibull";
		}
		if (m_modelName == NORMAL)
		{
			strRet = "normal";
		}
		if (m_modelName == EXPONENTIAL)
		{
			strRet = "exponentiaL";
		}
		if (m_modelName == EXPONENTIAL_LINEAR_REGRESSION)
		{
			strRet = "exponential-lr";
		}
		if (m_modelName == EXPONENTIAL_MEAN)
		{
			strRet = "exponential-me";
		}
		if (m_modelName == PARETO)
		{
			strRet = "pareto";
		}
		if (m_modelName == PARETO_LINEAR_REGRESSION)
		{
			strRet = "pareto-lt";
		}
		if (m_modelName == PARETO_MAXIMUM_LIKEHOOD)
		{
			strRet = "pareto-ml";
		}
		if (m_modelName == CAUCHY)
		{
			strRet = "cauchy";
		}
		if (m_modelName == CONSTANT)
		{
			strRet = "constant";
		}
		if (m_modelName == SINGLE_PACKET)
		{
			strRet = "single-packet";
		}
		if (m_modelName == NO_MODEL)
		{
			strRet = "no-model-selected";
		}

		return (strRet);
	}

	// <TESTED>
	void strModelName(char* cStr) const
	{
		if (m_modelName == WEIBULL)
		{
			strcpy(cStr, "weibull");
		}
		if (m_modelName == NORMAL)
		{
			strcpy(cStr, "normal");
		}
		if (m_modelName == EXPONENTIAL)
		{
			strcpy(cStr, "exponentiaL");
		}
		if (m_modelName == EXPONENTIAL_LINEAR_REGRESSION)
		{
			strcpy(cStr, "exponential-lr");
		}
		if (m_modelName == EXPONENTIAL_MEAN)
		{
			strcpy(cStr, "exponential-me");
		}
		if (m_modelName == PARETO)
		{
			strcpy(cStr, "pareto");
		}
		if (m_modelName == PARETO_LINEAR_REGRESSION)
		{
			strcpy(cStr, "pareto-lt");
		}
		if (m_modelName == PARETO_MAXIMUM_LIKEHOOD)
		{
			strcpy(cStr, "pareto-ml");
		}
		if (m_modelName == CAUCHY)
		{
			strcpy(cStr, "cauchy");
		}
		if (m_modelName == CONSTANT)
		{
			strcpy(cStr, "constant");
		}
		if (m_modelName == SINGLE_PACKET)
		{
			strcpy(cStr, "single-packet");
		}
		if (m_modelName == NO_MODEL)
		{
			strcpy(cStr, "no-model-selected");
		}

	}
	stochastic_functions modelName() const
	{
		return (m_modelName);
	}

	double param1() const
	{
		return (m_param1);
	}

	double param2() const
	{
		return (m_param2);
	}

	void set(stochastic_functions sf, double param1, double param2, double aic,
			double bic)
	{
		m_modelName = sf;
		m_param1 = param1;
		m_param2 = param2;
		m_aic = aic;
		m_bic = bic;
	}

	void setInforCriterion(information_criterion infoCrit)
	{
		m_infoCrit = infoCrit;
	}

	bool operator <(const StochasticModelFit& smf) const
	{
		if (m_infoCrit == AIC)
		{
			return (m_aic < smf.aic());
		}
		else
		{
			return (m_bic < smf.bic());
		}
	}

	bool operator >(const StochasticModelFit& smf) const
	{
		if (m_infoCrit == AIC)
		{
			return (m_aic > smf.aic());
		}
		else
		{
			return (m_bic > smf.bic());
		}
	}

	StochasticModelFit(const StochasticModelFit& other)
	{
		m_modelName = other.modelName();
		m_param1 = other.param1();
		m_param2 = other.param2();
		m_aic = other.aic();
		m_bic = other.bic();
	}
	StochasticModelFit& operator=(const StochasticModelFit& other) noexcept
	{
		if (this != &other)
		{
			//m_modelName = other.m_modelName;
			m_modelName = other.modelName();
			m_param1 = other.param1();
			m_param2 = other.param2();
			m_aic = other.aic();
			m_bic = other.bic();
			m_infoCrit = other.m_infoCrit;
		}
		else
		{
			cerr
					<< "Attempted assignment of a StochasticModelFit object to itself"
					<< endl;
		}

		return (*this);
	}

	void print() const
	{
		cout << strModelName() << "(" << m_param1 << ", " << m_param1 << ") "
				<< "aic=" << m_aic << ", bic=" << m_bic << endl;
	}

private:

	//stochastic_functions m_modelName = NO_MODEL;

	stochastic_functions m_modelName;
	double m_aic;
	double m_bic;
	double m_param1;
	double m_param2;
	information_criterion m_infoCrit = AIC;
};

//int compareBic(const void* a, const void* b);
//int compareAic(const void* a, const void* b);

#endif /* STOCHASTICMODELFIT_H_ */
